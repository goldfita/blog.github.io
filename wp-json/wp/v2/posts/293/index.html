{"id":293,"date":"2023-01-19T14:36:10","date_gmt":"2023-01-19T19:36:10","guid":{"rendered":"https:\/\/blog.signalsguru.net\/?p=293"},"modified":"2023-05-09T19:30:33","modified_gmt":"2023-05-09T23:30:33","slug":"migrating-to-fish-from-bash","status":"publish","type":"post","link":"http:\/\/blog.signalsguru.net\/archives\/293","title":{"rendered":"Migrating to Fish from Bash"},"content":{"rendered":"\n<h2 class=\"wp-block-heading\">Overview<\/h2>\n\n\n\n<p>Switching to the <a href=\"https:\/\/fishshell.com\/\">Fish shell<\/a> when you have a bunch of existing Bash scripts can be quite a challenge due incompatibilities with functions and the inability to source scripts from another language. There is at least one plugin which attempts to solve some of these problems, but I have not looked at it. Instead I used the suggested trick below. However, this alone is not enough. It needs a lot more work to make it usable. This replaces the fish shell with a bash shell that runs your script. When the script is done, it replaces the bash shell with a fish shell, leaving you back in fish.<\/p>\n\n\n\n<pre class=\"wp-block-code has-vivid-cyan-blue-color has-text-color\"><code>exec bash -c \"bash_script.sh; exec fish\"<\/code><\/pre>\n\n\n\n<p>The major problems are that (1) you can&#8217;t run bash functions in fish, and (2) you can&#8217;t source a bash script into fish, which means any variables set in the bash script will not be available in your fish shell. If you don&#8217;t have existing scripts or you only have a small number of them, and they are easy to change, the solution to these two problems is easy: don&#8217;t use functions and don&#8217;t set variables through sourcing. Since this wasn&#8217;t an option for me, I solved the problem by writing all the bash functions to individual scripts, creating wrappers around the functions, and defining a function to export variables that has the same syntax in both fish and bash. Before I go any further, let me say that I strongly recommend, if you have any other option, against doing it this way for the following reasons.<\/p>\n\n\n\n<ul>\n<li>Because each script and function now calls <mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">exec fish<\/mark> at the end, you can no longer combine multiple scripts in a single command or in another script. Anything that happens after the first bash script will be lost.<\/li>\n\n\n\n<li>This took me a few days to get working, and it was extremely difficult to debug due to the extra layer introduced by the wrappers.<\/li>\n\n\n\n<li>It requires some ugly changes to <mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">config.fish<\/mark>.<\/li>\n\n\n\n<li>Each time you <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">exec fish<\/mark>, it runs through the initialization, including <mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">config.fish<\/mark>, which may have some undesirable consequences as I&#8217;ll explain.<\/li>\n<\/ul>\n\n\n\n<h2 class=\"wp-block-heading\">Making Fish Feel More Like Bash<\/h2>\n\n\n\n<p>I first want to get into the various other differences between fish and bash that I&#8217;ve discovered. Then I&#8217;ll get to the wrappers, I promise. Fish doesn&#8217;t use history the same way as bash. If you want to reproduce something like bash history, you can do the following. Because fish is pretty good at figuring out what you want to type, there is somewhat less need for history. The <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">fish_command_not_found<\/mark> lets you intercept unbound commands. Then you can examine the command to see if it&#8217;s a bash history command (i.e. !nnn), select that number from history, and run it. Otherwise, run the default handler.<\/p>\n\n\n\n<pre class=\"wp-block-code scroll has-vivid-cyan-blue-color has-text-color\"><code>if status --is-interactive\n    alias !!     'eval_hist \"$history&#91;1]\"'\n    # I'm not using search because the numbering won't be consistent with !nnn\n    alias histgrep \"history --reverse | nl | grep $arvg&#91;1]\"\n    alias hist     \"history --reverse | nl\"\n\n    # Putting an extra character in front stops it from being added to history\n    abbr --add -g !!       ' !!'\n    abbr --add -g histgrep ' histgrep'\n    abbr --add -g hist     ' hist'\n\n    # Roughly equivalent to !nnn in bash.\n    function fish_command_not_found\n        if &#91; (count $argv) = 1 ]; and test ! -z \"(string match -r '!&#91;&#91;:digit:]]+' \"$argv&#91;1]\")\"\n            set -l num (string sub -s 2 $argv&#91;1])\n            set -l cmd (history --reverse | nl | grep (printf \"^&#91;&#91;:space:]]*%s&#91;&#91;:space:]]*\" \"$num\") | cut -f 2)\n            if test -z (string match -r '!' \"$cmd\")\n                builtin history delete --exact --case-sensitive \"!$num\"\n                eval_hist \"$cmd\"\n            end\n        else\n            __fish_default_command_not_found_handler $argv\n        end\n    end\n\n    # This has nothing to do with history.\n    # It's a nice Emacs way to quit out of completions.\n    bind \\cg 'cancel'\nend\n\nset -lx add_hist 'printf \\\"%s cmd: %s\\n  when: %s\\n\\\" \\\"-\\\" \\\"\\$last_cmd\\\" \\$(date \"+%s\") &gt;&gt; ~\/.local\/share\/fish\/fish_history'\n\neval \"function eval_hist; set -l last_cmd \\\"\\$argv\\\"; eval \\\"\\$last_cmd; $add_hist\\\"; history --merge; end\"\n<\/code><\/pre>\n\n\n\n<p>If you are using the <a href=\"https:\/\/unix.stackexchange.com\/questions\/1288\/preserve-bash-history-in-multiple-terminal-windows\">prompt command trick<\/a> to preserve history across multiple terminals, you&#8217;ll probably want to do the same in fish. Initially I went with this.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code><mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">functions --copy fish_prompt _fish_prompt\nfunction fish_prompt\n    history merge\n    _fish_prompt\nend<\/mark><\/code><\/pre>\n\n\n\n<p>But pretty soon I realized it was merging history in every terminal after every command immediately. This is really annoying. I don&#8217;t want to enter the up key to get the previous thing I typed and instead get something I typed in another terminal. And the solution, instead, is to do absolutely nothing! Fish already saves each command you type in each terminal to a <a href=\"https:\/\/github.com\/fish-shell\/fish-shell\/issues\/862\">history file<\/a>. However, I soon discovered that sometimes it was still merging in history from other terminals. This was due to running <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">exec fish<\/mark> after a bash command. Running the initialization pulls in the merged history file. This is one of the undesirable consequences I was speaking about.<\/p>\n\n\n\n<p>One of my bash scripts does something like the following in order to re-display the prompt after a background script completes. If I don&#8217;t do this, I inevitably end up staring at the terminal, wondering what&#8217;s taking so long when the script finished three minutes ago.<\/p>\n\n\n\n<pre class=\"wp-block-code has-vivid-cyan-blue-color has-text-color\"><code># bash function\n{\n    bind '\"\\e&#91;0n\": \"\\n\"'\n    (\n        printf \"Running command in background\\n\"\n        command\n        # <a href=\"https:\/\/unix.stackexchange.com\/questions\/213799\/can-bash-write-to-its-own-input-stream\">can-bash-write-to-its-own-input-stream<\/a>\n        printf '\\e&#91;5n'\n    ) &amp; disown;\n} 2&gt;\/dev\/null<\/code><\/pre>\n\n\n\n<p>Unfortunately, this binding is lost when you <mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">exec fish<\/mark>. You will need the following in config.fish. I don&#8217;t think there is any way to create this binding just temporarily.<\/p>\n\n\n\n<pre class=\"wp-block-code has-vivid-cyan-blue-color has-text-color\"><code>bind \\e'&#91;0n' \"echo;fish_prompt\"<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\">Reusing Bash Functions and Scripts<\/h2>\n\n\n\n<p>The first step is to write each bash function to a function in its own script by the same name. You can do this with <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">type<\/mark> or <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">declare -f<\/mark>. The function and script name should have some extra characters pre-pended or appended because there will be a wrapper with the same name around the script. Every bash script\/function will need a fish wrapper. Note that we&#8217;re wrapping both existing scripts and scripts we created from functions.<\/p>\n\n\n\n<pre class=\"wp-block-code scroll has-vivid-cyan-blue-color has-text-color\"><code>function create_wrapper\n    eval \"function $argv&#91;1]; history --merge; exec env last_cmd=\\\"\\$history&#91;1]\\\" bash -c \\\". \\\\\\\"\\$SHELL_PATH\/wrappers.sh\\\\\\\"; trap ':' SIGINT; do_script \\\\\\\"$argv&#91;1]\\\\\\\" \\$(printf '\\\"%s\\\" ' \\$argv); eval '$add_hist'; exec env USE_WRAPPER=1 fish\\\"; end\"\nend\n\nfor fname in $(ls \"$SCRIPTS_PATH\")\n    create_wrapper \"$fname\"\nend<\/code><\/pre>\n\n\n\n<p>The <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">SCRIPTS_PATH<\/mark> is just whatever directory you have placed your scripts in. There will be a few scripts needed to make this work,  so I made a <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">SHELL_PATH<\/mark>. This creates a fish function for each bash function and uses the trick mentioned at the beginning to invoke the function in bash and then change back to fish. As soon as we switch to bash, we need to create function wrappers there as well. This is the purpose of <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">wrappers.sh<\/mark>. The reason for this is that this is neither a login shell nor an interactive shell, so none of the functions will yet exist. And recall that the script names for the corresponding functions were intentionally named slightly differently to avoid shadowing the function that the script calls. The difference between the bash wrappers and the fish wrappers is that the bash wrappers only wrap scripts that were generated from functions, whereas the fish wrappers wrap all scripts and functions. Also note that it&#8217;s not sufficient to create a wrapper for only the function you are calling because that function may call other scripts or functions.<\/p>\n\n\n\n<p>The next command intercepts <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">SIGINT<\/mark>, and does nothing. The reason for this is that when you hit <mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">Ctrl-C<\/mark> while in bash, it crashes the fish shell. I don&#8217;t understand why this happens, but this fixes the problem. Then we call a function which runs the function or script. This function needs to be passed the name of the function\/script to run as well as all the arguments. Finally, we replace the bash shell with fish and pass an environment variable, <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">USE_WRAPPER<\/mark>, indicating that the shell was called from a wrapper function. I discovered the need for this flag when my environment variables kept getting over-written. Unlike bash, fish always runs the init script, <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">config.fish<\/mark>. My init script sets up all my environment variables, and they were getting clobbered each time the wrapper was run. Some scripts modify environment variables; that may be their entire purpose. So resetting them is definitely not the desired behavior.<\/p>\n\n\n\n<p>The wrappers for bash follows. Note that it excludes scripts since we only need wrappers for functions. Functions-as-scripts are sourced so that they behave like functions with respect to setting environment variables. The bash version of the wrapper also intercepts <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">SIGINT<\/mark>. I believe the reason for this was that hitting <mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">Ctrl-C<\/mark> was causing the interrupted script to drop into the bash shell instead of fish.<\/p>\n\n\n\n<pre class=\"wp-block-code scroll has-vivid-cyan-blue-color has-text-color\"><code># wrappers.sh\nfunction create_wrapper { eval \"function ${1} { trap ':' SIGINT; run_script \\\"${1}\\\" \"\\$@\"; }; export -f ${1}\"; }\n\nfunction do_script {\n    local script=\"$1\"\n    shift\n    if &#91;&#91; \"$script\" =~ \".sh\" ]]; then\n        \"${SCRIPTS_PATH}\/${script}\" \"$@\"\n    else\n        . \"${SCRIPTS_PATH}\/${script}\" \"$@\"\n    fi\n}\n\nfor fname in $(ls \"$SCRIPTS_PATH\" -I '*.sh'); do\n    create_wrapper \"$fname\"\ndone\n\nexport -f do_script\nunset -f create_wrapper<\/code><\/pre>\n\n\n\n<p>Fish prints a greeting. We don&#8217;t want to see this every time we run a bash function or script. The following needs to go somewhere in the init file.<\/p>\n\n\n\n<pre class=\"wp-block-code has-vivid-cyan-blue-color has-text-color\"><code>function fish_greeting; end<\/code><\/pre>\n\n\n\n<p>There is still one step left. Since there is now a script shadowing every function, you will still need to source the wrapper script from <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">.bashrc<\/mark> for functions to work properly when using bash. And you will occasionally need to work in bash to fix scripts.<\/p>\n\n\n\n<pre class=\"wp-block-code has-vivid-cyan-blue-color has-text-color\"><code>. \"$SHELL_PATH\"\/wrappers.sh<\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\">Common Environment Variables and Aliases<\/h2>\n\n\n\n<p>Even though fish and bash have incompatible syntax, it is possible to source a single, common script into either environment as long as you limit the script to using only syntax common to both fish and bash. This is helpful for defining environment variables and aliases in your init files. By defining a function for <mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">setenv<\/mark> and <mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">alias<\/mark> in bash, you can make it have the same syntax as fish. Put the following in <mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">.bashrc<\/mark>.<\/p>\n\n\n\n<pre class=\"wp-block-code has-vivid-cyan-blue-color has-text-color\"><code><mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\"># bashrc\nfunction setenv { export \"$1=$2\"; }\nfunction _alias { unalias alias; alias \"$1=$2\"; alias alias=_alias; }\nalias alias=_alias\n\n# source bash_env<\/mark> if USE_WRAPPER is not set\n. env<mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">\n\nunalias alias\nunset -f _alias -f setenv<\/mark><\/code><\/pre>\n\n\n\n<p>Then add the script or scripts with environment variables and aliases. I believe newer versions of fish have syntactic sugar for making some of this bash syntax work in fish.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code><mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\"># env; can source a script with these\nsetenv SCRIPTS_PATH \"\/home\/user\/scripts\"\nalias cp            \"cp -i -p\"<\/mark><\/code><\/pre>\n\n\n\n<h2 class=\"wp-block-heading\">Setting Paths from Bash<\/h2>\n\n\n\n<p>There is still one last problem, well one that I know how to fix. You can&#8217;t use the <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">exec fish<\/mark> trick in your <mark data-darkreader-inline-bgcolor=\"\" style=\"background-color: rgba(0, 0, 0, 0); --darkreader-inline-bgcolor:rgba(13, 13, 13, 0);\" class=\"has-inline-color has-vivid-cyan-blue-color\">config.fish<\/mark>. I don&#8217;t understand why, but it breaks the X11 login. Logging in from terminal works just fine. What you can do instead is use the universal environment variable mechanism. Run a bash script that sources all the paths you want. Then run a fish shell that permanently sets all the paths in fish. This was tricky to get right. I had some path variables that were getting changed in bash and then were used to modify the path. When calling fish from bash, the bash path gets imported into fish, but I was having issues with paths being reordered and\/or duplicated. I finally settled on the following.<\/p>\n\n\n\n<pre class=\"wp-block-code scroll\"><code><mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">if status --is-login\n    if not string match -r -q 'universal' \"$(set --show fish_user_paths)\"\n        set -Ux fish_pager_color_selected_background --background=<\/mark><mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-ast-global-color-1-color\">'#990000'<\/mark><mark style=\"background-color:rgba(0, 0, 0, 0)\" class=\"has-inline-color has-vivid-cyan-blue-color\">\n        set -Ux fish_pager_color_background --background='#000040'\n        bash -c \". \/opt\/rh\/additional-software\/enable; exec fish -c 'set -U fish_user_paths \\$PATH; set -Ux ANOTHERPATH \\$ANOTHERPATH;'\"\n    end\n    # This needs to happen after setting fish_user_paths to PATH in bash above.\n    # Otherwise, if SOME_OTHER_PATH is in fish_user_paths, path will not be\n    # correct after modifying PATH in a bash script.\n    set -g PATH \"$SOME_OTHER_PATH\" $PATH\nend<\/mark><\/code><\/pre>\n\n\n\n<p>You probably noticed I changed the pager color. This is because the default background color is the same color as the terminal.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Overview Switching to the Fish shell when you have a bunch of existing Bash scripts can be quite a challenge due incompatibilities with functions and the inability to source scripts from another language. There is at least one plugin which attempts to solve some of these problems, but I have not looked at it. Instead &hellip;<\/p>\n<p class=\"read-more\"> <a class=\"\" href=\"http:\/\/blog.signalsguru.net\/archives\/293\"> <span class=\"screen-reader-text\">Migrating to Fish from Bash<\/span> Read More &raquo;<\/a><\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"site-sidebar-layout":"default","site-content-layout":"default","ast-global-header-display":"","ast-main-header-display":"","ast-hfb-above-header-display":"","ast-hfb-below-header-display":"","ast-hfb-mobile-header-display":"","site-post-title":"","ast-breadcrumbs-content":"","ast-featured-img":"","footer-sml-layout":"","theme-transparent-header-meta":"","adv-header-id-meta":"","stick-header-meta":"","header-above-stick-meta":"","header-main-stick-meta":"","header-below-stick-meta":"","footnotes":""},"categories":[12],"tags":[],"_links":{"self":[{"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/posts\/293"}],"collection":[{"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/comments?post=293"}],"version-history":[{"count":16,"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/posts\/293\/revisions"}],"predecessor-version":[{"id":388,"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/posts\/293\/revisions\/388"}],"wp:attachment":[{"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/media?parent=293"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/categories?post=293"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/blog.signalsguru.net\/wp-json\/wp\/v2\/tags?post=293"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}